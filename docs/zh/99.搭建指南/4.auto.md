# 自动化

## 目标

自动识别文档目录，并生成相应的导航栏和侧边栏

以本项目 wheatear 为例

当前 docs/ 下的目录结构如下

```bash
.
├── .vuepress
│   ├── config.js
│   ├── nav
│   │   └── zh.js
│   └── public
├── README.md
└── zh
    └── guide
        ├── auto.md
        ├── create.md
        ├── deploy.md
        └── locales.md
```

## 获取文档目录

::: warning

这里约定文档目录下同一层级只有目录或者只有文档

:::

在 docs/.vuepress/nav/ 目录下新建 index.js，代码如下

```javascript
const path = require('path');
const fse = require('fs-extra');

// 查找到目标目录 docs
const source = path.resolve(__dirname);
const targetDirectory = 'docs';
const lastIndex = source.lastIndexOf(targetDirectory);
const targetPath = source.substring(0, lastIndex + targetDirectory.length);

// 排除以下文件
const excludes = ['.DS_Store'];

/**
 * 获取当前目录下的文档/目录
 * @param {string} currentDirectoryPath 包含 lang 及之后的路径
 */
function getDirectoryFiles(currentDirectoryPath) {
  const directoryFiles = fse.readdirSync(`${targetPath}/${currentDirectoryPath}`, {
    encoding: 'utf8',
    withFileTypes: true,
  }).filter(dirent => !excludes.includes(dirent.name));

  let hasReadme = false;
  // 没有子目录的目录
  let isPureDirectory = true;

  const files = directoryFiles.map(dirent => {
    const file = {
      originName: dirent.name,
      // 用于处理路径相关的 = dirent.name 只在README.md 时 = '' 
      pathName: dirent.name,
      text: undefined,
      link: `/${currentDirectoryPath}/${dirent.name}`,
      children: undefined,
      hasReadme: undefined,
      isPureDirectory: true,
    };
    if (dirent.isFile()) {
      if (dirent.name === 'README.md') {
        file.text = '';
        file.pathName = '',
          hasReadme = true;
      } else {
        file.text = getFileName(dirent);
      }
    } else if (dirent.isDirectory()) {
      const childrenFiles = getDirectoryFiles(`${currentDirectoryPath}/${dirent.name}`);
      file.text = getFileName(dirent);
      file.children = childrenFiles.files;
      file.hasReadme = childrenFiles.hasReadme;
      file.isPureDirectory = childrenFiles.isPureDirectory;
      isPureDirectory = false;
    }
    return file;
  }).sort((a, b) => a.pathName ? a.pathName - b.pathName : -1); // 始终将 README.md 放在第一个

  return {
    files,
    hasReadme,
    isPureDirectory,
  }
}

/**
 * 获取文档/目录名称
 * @param {Object} dirent 
 */
function getFileName(dirent) {
  const fileName = dirent.name;
  // 形如 数字.name.类型 其中数字和类型是可选的
  // 例 1.aa.md | bb.md | cc
  const lastIndex = fileName.lastIndexOf('.');
  if (lastIndex === -1) return fileName;

  let nameWithoutSuffix;
  if (dirent.isFile()) {
    nameWithoutSuffix = fileName.substring(0, lastIndex);
  } else {
    nameWithoutSuffix = fileName;
  }
  const firstIndex = fileName.indexOf('.');
  if (firstIndex === -1) return nameWithoutSuffix;
  return nameWithoutSuffix.substring(firstIndex + 1);
}

/**
 * 获取导航栏
 * @param {Array} files 
 */
function getItems(files) {
  return files.map(file => {
    if (Array.isArray(file.children) && file.children.length > 0) {
      if (file.isPureDirectory) {
        return {
          text: file.text,
          // 没有 README.md 时取第一个子文件
          link: file.hasReadme ? `${file.link}/` : `${file.link}/${file.children[0].pathName}`,
        }
      }
      return {
        text: file.text,
        items: getItems(file.children),
      }
    }
  })
}

/**
 * 获取侧边栏
 * @param {Array} files 
 */
function getSidebar(files) {
  const sidebar = {};
  const getChildren = (files) => {
    files.forEach(file => {
      if (file.isPureDirectory) {
        sidebar[`${file.link}/`] = [{
          title: file.text,
          collapsable: false,
          children: file.children.map(x => x.pathName)
        }]
      } else if (file.children.length > 0) {
        getChildren(file.children);
      }
    })
  }
  getChildren(files);
  return sidebar;
}


// 示例
// const lang = 'zh';
// const { files } = getDirectoryFiles(lang);
// const nav = getItems(files);
// const sidebar = getSidebar(files);
// console.log(files);
// console.log(nav);
// console.log(sidebar);


module.exports = {
  getDirectoryFiles,
  getNav: getItems,
  getSidebar,
};
```

::: tip

对于包含 README.md 的目录，导航栏指向目录，否则指向第一个文件的位置

可以在给目录/文件命名时，添加 x. 前缀用以指定排序

:::

示例获得的导航栏结构如下

```json
[{ "text": "guide", "link": "/zh/guide/auto" }]
```

侧边栏结构如下

```json
{
  "/zh/guide/": [
    {
      "title": "guide",
      "collapsable": false,
      "children": ["auto", "create", "deploy", "locales"]
    }
  ]
}
```

修改 docs/.vuepress/nav/zh.js 为

```javascript
const { getDirectoryFiles, getNav, getSidebar } = require("./index");

const { files } = getDirectoryFiles("zh");
const nav = getNav(files);
const sidebar = getSidebar(files);

console.log(nav);

// 可以在这里再次进行处理

module.exports = {
  nav,
  sidebar
};
```

这里保留 zh.js 方便对不同语言进行再次配置

## 修改配置

打开 docs/.vuepress/config.js

```js
// 头部添加
const { nav, sidebar } = require('./nav/zh');

// 修改导航栏、侧边栏
themeConfig = {
  ...,
  nav,
  sidebar,
  ...,
}
```

修改目录/文件名称后重新启动开发环境/重新编译即可
